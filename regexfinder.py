import numpy as npimport refrom graphviz import Digraphfrom itertools import combinationsimport more_itertools as mitdef strNumberGenerator():     number = 0     while True:         yield str(number)         number += 1         strCounter = strNumberGenerator()def topOrExists(inString):    topORs = getTopOR(inString)    return bool(topORs)def getTopOR(inString):    # find or symbols '|' that are not contained within any parentheses    matches = re.finditer(r"\|" ,inString)    matches = list(matches)    orLocations = []    for match in matches:        orLocations.append(match.start())        p,c = outerParentheses(inString)    inParentheses = [list(range(x[0],x[1])) for x in p]    topOrs = [x for x in orLocations if not any([x in r for r in inParentheses])]    return topOrsdef getTopOrSegments(inString):    topORs = getTopOR(inString)    if not topORs:        return [inString]    else:        toReturn = []        t1 = [0] + [x +1 for x in topORs]        t2 = topORs + [len(inString)]        endPoints = list(zip(t1,t2))        return [inString[x:y] for x,y in endPoints]    def outerParentheses(inString):    v = 0    out = []    for s in inString:        if s == '(':            v += 1        elif s == ')':            v -= 1        else:            pass        out.append(v)    starts = [i + 1 for i in range(len(out)-1) if (out[i]==0 and out[i+1]==1)]    if out[0] == 1:        starts = [0] + starts            ends = [i +1 for i in range(1,len(out)) if (out[i-1]==1 and out[i]==0)]    t1 = [0] + ends    t2 = starts + [len(inString)]    complements = list(zip(t1,t2))    #print('starts:' ,starts)    #print('ends: ',ends)    if not len(starts) == len(ends):       raise Exception('len(starts) does not equal len(ends)')    parentheses = list(zip(starts,ends))        parentheses = [p for p in parentheses if p[0]<p[1]]    complements = [c for c in complements if c[0]<c[1]]    return parentheses,complementsdef getParenthesesSegments(inString):    p,c = outerParentheses(inString)    r = p+c    r.sort(key = lambda x:x[1])    segments = [inString[x[0]:x[1]] for x in r]    segments = [removeOuterParentheses(s) for s in segments]    return segmentsdef removeOuterParentheses(inString):    if inString[0] == '(' and inString[-1] == ')':        return inString[1:-1]    else:        return inString    def getClassQuantList(inString):    matches = re.finditer(r"(\[[^]]+\]|\\d|\\w|\\W|.)(\?|\+|\*|\{\d?,?\d?\})?" ,inString)    matches = list(matches)    toReturn = []    for match in matches:        groups = list(match.groups())        if not len(groups) == 2:            raise Exception('Expected 2 groups. Received ',len(groups))        toReturn.append({'class':groups[0],'quantifier':groups[1]})    return toReturndef partitionClass(inString):    matches = re.finditer(r"(\w-\w)|\w",inString)    matches = list(matches)    return [match.group() for match in matches]class GRAPH:   def __init__(self,regex):      self.regex = regex      try:          re.compile(self.regex)      except:         raise Exception('Invalid argument. re.compile failed')              self.startNode = NODE(self.regex)      self.nodes = {self.startNode.id : self.startNode}      self.edges = []       def addNode(self,node):      if node.id in self.nodes.keys():            raise Exception('Node key already exists')      self.nodes[node.id] = node     def addEdge(self,a,b):      self.edges.append((a,b))   def removeEdge(self,a,b):      if (a,b) in self.edges:         self.edges.remove((a,b))   def getParents(self,id):      return [x[0] for x in self.edges if x[1] == id]   def getChildren(self,id):      return [x[1] for x in self.edges if x[0] == id]      def getNotSimple(self):       return [id for id,node in self.nodes.items() if (not node.replaced and not node.simple)]   def simplify(self):      while self.getNotSimple():          self.process(self.getNotSimple()[0])         def createGraph(self):      dot = Digraph()              for key,node in self.nodes.items():         if not node.replaced:            dot.node(str(node.id),node.regex)            for edge in self.edges:         print(edge)            dot.edge(edge[0],edge[1])            #print(dot.source)      dot.render(view=True)      def process(self,id):                   if self.nodes[id].topOrExists:         segments = getTopOrSegments(self.nodes[id].regex)         self.nodes[id].replaced = True         parents = self.getParents(self.nodes[id].id)         children = self.getChildren(self.nodes[id].id)         for segment in segments:                n = NODE(segment)                self.addNode(n)                for parent in parents:                   self.removeEdge(parent,self.nodes[id].id)                    self.addEdge(parent,n.id)                for child in children:                   self.removeEdge(self.nodes[id].id,child)                    self.addEdge(n.id,child)                                        elif '(' in self.nodes[id].regex:         segments = getParenthesesSegments(self.nodes[id].regex)         parents = self.getParents(self.nodes[id].id)         children = self.getChildren(self.nodes[id].id)         self.nodes[id].replaced = True         n = NODE(segments[0])         self.addNode(n)         previous = n.id         for parent in parents:             self.removeEdge(parent,self.nodes[id].id)             self.addEdge(parent,n.id)         for segment in segments[1:]:                print('segment: ',segment)                n = NODE(segment)                self.addNode(n)                self.addEdge(previous,n.id)                previous = n.id                           for child in children:                self.removeEdge(self.nodes[id].id,child)             self.addEdge(n.id,child)                   else:         cQList = getClassQuantList(self.nodes[id].regex)         parents = self.getParents(self.nodes[id].id)         self.nodes[id].replaced = True         toString = lambda d : d['class'] + d['quantifier'] if d['quantifier'] else d['class']         n = NODE(toString(cQList[0]),simple=True)         self.addNode(n)         previous = n.id         for parent in parents:             self.addEdge(parent,n.id)                      self.removeEdge(parent,self.nodes[id].id)         for cQ in cQList[1:]:                n = NODE(toString(cQ),simple=True)                self.addNode(n)                self.addEdge(previous,n.id)                previous = n.id                          children = self.getChildren(self.nodes[id].id)         for child in children:             self.removeEdge(self.nodes[id].id,child)              self.addEdge(previous,child)                       class NODE:   def __init__(self,regex,replaced=False,simple=False,alpha=1):      self.node = None      self.alpha = alpha      self.regex = regex      self.id = next(strCounter)      self.removeOuterParentheses()      self.replaced = replaced      self.vector = None   @property   def simple(self):        return not ('(' in self.regex or '|' in self.regex or len(getClassQuantList(self.regex)) > 1)     @property            def topOrExists(self):      return topOrExists(self.regex)           def removeOuterParentheses(self):      while self.regex[0] == '(' and self.regex[-1] == ')':            self.regex = self.regex[1:-1]   def createVector(self):       assert self.simple       vector = np.zeros(128,dtype=int)           if self.regex == '\d':          vector[48:58] =1               elif self.regex == '\D':          vector[31:47] =1                  vector[59:127] =1                       elif self.regex == '\w':          vector[48:58] =1          vector[65:91] =1                  vector[95] =1                  vector[97:123] =1                 elif self.regex == '\W':          vector[31:48] =1          vector[58:65] =1                  vector[91:95] =1                  vector[96] =1                    vector[123:127] =1                       elif '[' in self.regex:          pieces = partitionClass(self.regex)          for piece in pieces:            if '-' in piece:                start = ord(piece[0])                end = ord(piece[2]) + 1                vector[start:end] = 1            else:                vector[ord(piece)] = 1       self.vector = vector    @property     def cardinality(self):      if self.vector is not None:         self.createVector()      return sum(self.vector)    @property     def entropy(self):      return round(np.log2(self.cardinality),4)    @property     def K(self):      return(len(self.regex))   @property   def phi(self):      return self.entropy + self.alpha * self.K         class VECTOR:    def __init__(self,vector,alpha = None):        self.v = vector        self.alpha = alpha    @property    def regex(self):        toReturn = ''        for subList in self.consecutiveSublists:           subList = [chr(x) for x in subList]           if len(subList) == 0:             pass           elif len(subList) == 1:             toReturn += subList[0]           elif len(subList) == 2:             toReturn += subList[0]             toReturn += subList[1]           else:             toReturn += subList[0]             toReturn += '-'             toReturn += subList[-1]        return toReturn                            def reduce(self):        flatten = lambda x : [y for z in x for y in z]              subLists = self.consecutiveSublists        combs = [list(combinations(subLists,i)) for i in range(1,len(subLists)+1)]        combs = flatten(combs)        for comb in combs:           support = flatten(comb)           first = min(support)           last = max(support)           temp = VECTOR(self.v.copy(),self.alpha)           temp.v[first:last] = 1           if temp.phi < self.phi:              self.v = temp.v    @property    def consecutiveSublists(self):        return [list(group) for group in mit.consecutive_groups(self.support)]        @property    def minIndex(self):        return np.min(np.where(self.v))            @property    def maxIndex(self):        return np.max(np.where(self.v))    @property    def ent(self):        return round(np.log2(np.sum(self.v)),4)    @property    def support(self):        return np.where(self.v)[0]        @property    def K(self):             return len(self.regex)        @property    def phi(self):        return self.ent + self.alpha * self.K