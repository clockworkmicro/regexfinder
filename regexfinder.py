import numpy as npimport pandas as pdimport refrom graphviz import Digraphfrom itertools import combinationsimport more_itertools as mitimport randomdef strNumberGenerator():     number = 0     while True:         yield str(number)         number += 1         strCounter = strNumberGenerator()def topOrExists(inString):    topORs = getTopOR(inString)    return bool(topORs)def getTopOR(inString):    # find or symbols '|' that are not contained within any parentheses    matches = re.finditer(r"\|" ,inString)    matches = list(matches)    orLocations = []    for match in matches:        orLocations.append(match.start())        p,c = outerParentheses(inString)    inParentheses = [list(range(x[0],x[1])) for x in p]    topOrs = [x for x in orLocations if not any([x in r for r in inParentheses])]    return topOrsdef getTopOrSegments(inString):    topORs = getTopOR(inString)    if not topORs:        return [inString]    else:        t1 = [0] + [x +1 for x in topORs]        t2 = topORs + [len(inString)]        endPoints = list(zip(t1,t2))        return [inString[x:y] for x,y in endPoints]    def outerParentheses(inString):    v = 0    out = []    for s in inString:        if s == '(':            v += 1        elif s == ')':            v -= 1        else:            pass        out.append(v)    starts = [i + 1 for i in range(len(out)-1) if (out[i]==0 and out[i+1]==1)]    if out[0] == 1:        starts = [0] + starts            ends = [i +1 for i in range(1,len(out)) if (out[i-1]==1 and out[i]==0)]    t1 = [0] + ends    t2 = starts + [len(inString)]    complements = list(zip(t1,t2))    #print('starts:' ,starts)    #print('ends: ',ends)    if not len(starts) == len(ends):       raise Exception('len(starts) does not equal len(ends)')    parentheses = list(zip(starts,ends))        parentheses = [p for p in parentheses if p[0]<p[1]]    complements = [c for c in complements if c[0]<c[1]]    return parentheses,complementsdef getParenthesesSegments(inString):    p,c = outerParentheses(inString)    r = p+c    r.sort(key = lambda x:x[1])    segments = [inString[x[0]:x[1]] for x in r]    segments = [removeOuterParentheses(s) for s in segments]    return segmentsdef removeOuterParentheses(inString):    if inString[0] == '(' and inString[-1] == ')':        return inString[1:-1]    else:        return inString    def getClassQuantList(inString):    matches = re.finditer(r"(\[[^]]+\]|\\d|\\w|\\W|.)(\?|\+|\*|\{\d?,?\d?\})?" ,inString)    toReturn = []    for match in matches:        groups = list(match.groups())        if not len(groups) == 2:            raise Exception('Expected 2 groups. Received ',len(groups))        entry = {'class':groups[0],'quantifier':groups[1]}        if groups[1]:                        matches2 = re.finditer(r"\d+" ,groups[1])            vals = [match2.group() for match2 in matches2]                if not vals:               entry['min'] = None               entry['max'] = None            elif len(vals) == 1:               entry['min'] = int(vals[0])               entry['max'] = int(vals[0])            elif len(vals) == 2:               entry['min'] = int(vals[0])               entry['max'] = int(vals[1])                    toReturn.append(entry)    return toReturndef partitionClass(inString):    #matches = re.finditer(r"(\w-\w)|\w",inString)       matches = re.finditer(r" ([^\[\]]-[^\[\]])|[^\[\]]",inString)    matches = list(matches)    return [match.group() for match in matches]class NODE:   def __init__(self,regex,replaced=False,simple=False,alpha=1):      self.node = None      self.alpha = alpha      self.regex = regex      self.id_ = next(strCounter)      self.removeOuterParentheses()      self.replaced = replaced      self.reduced = False      self.vector = None      self.classQuantList = getClassQuantList(self.regex)   @property   def simple(self):        return not ('(' in self.regex or '|' in self.regex or len(self.classQuantList) > 1)   @property            def topOrExists(self):      return topOrExists(self.regex)           def removeOuterParentheses(self):      while self.regex[0] == '(' and self.regex[-1] == ')':            self.regex = self.regex[1:-1]   def createVector(self):       assert self.simple       reClass = self.classQuantList[0]['class']       vector = np.zeros(128,dtype=int)              if len(reClass) == 1:           vector[ord(reClass)] = 1           elif reClass == '\d':          vector[48:58] = 1               elif reClass == '\D':          vector[31:47] = 1                  vector[59:127] = 1                       elif reClass == '\w':          vector[48:58] = 1          vector[65:91] = 1                  vector[95] = 1                  vector[97:123] = 1                 elif reClass == '\W':          vector[31:48] = 1          vector[58:65] = 1                  vector[91:95] = 1                  vector[96] =1                    vector[123:127] = 1                       elif '[' in reClass:          pieces = partitionClass(reClass)                    for piece in pieces:            if '-' in piece:                start = ord(piece[0])                end = ord(piece[2]) + 1                vector[start:end] = 1            else:                vector[ord(piece)] = 1       self.vector = VECTOR(vector,self.alpha)    def reduce(self):       if not self.simple:           raise Exception('Not is not simple. A node cannot be reduced if it is not simple.')       else:           if not self.vector:               self.createVector()           else:               pass           self.vector.reduce()           self.regex = self.vector.regex           self.reduced = True   @property     def cardinality(self):        if self.vector is None:           self.createVector()        valCount = sum(self.vector.v)         quantifier = self.classQuantList[0]['quantifier']                    if quantifier is None:           return valCount         elif quantifier == '?':           return valCount + 1        elif self.classQuantList[0]['min'] and self.classQuantList[0]['max']:            return sum([valCount**exponent for exponent in range(self.classQuantList[0]['min'],self.classQuantList[0]['max']+1)])                     else:            raise Exception('Check class quantifier')   @property     def entropy(self):      return round(np.log2(self.cardinality),4)    @property     def K(self):      return(len(self.regex))   @property   def phi(self):      return self.entropy + self.alpha * self.K     def match(self,inString,boolean=False):      matches = re.finditer(self.regex,inString)      if boolean:          return bool(list(matches))      else:         return matchesclass EDGE:   def __init__(self,parent,child,words=[]):      self.parent = parent      self.child = child      self.words = words         class VECTOR:    def __init__(self,vector,alpha = None):        self.v = vector        self.alpha = alpha    @property    def regex(self):        toReturn = ''        for subList in self.consecutiveSublists:           subList = [chr(x) for x in subList]           if len(subList) == 0:             pass           elif len(subList) == 1:             toReturn += subList[0]           elif len(subList) == 2:             toReturn += '['               toReturn += subList[0]             toReturn += subList[1]             toReturn += ']'             else:             toReturn += '['               toReturn += subList[0]             toReturn += '-'             toReturn += subList[-1]             toReturn += ']'          return toReturn                            def reduce(self):        flatten = lambda x : [y for z in x for y in z]              subLists = self.consecutiveSublists        combs = [list(combinations(subLists,i)) for i in range(1,len(subLists)+1)]        combs = flatten(combs)        for comb in combs:           support = flatten(comb)           first = min(support)           last = max(support)           temp = VECTOR(self.v.copy(),self.alpha)           temp.v[first:last] = 1           if temp.phi < self.phi:              self.v = temp.v    @property    def consecutiveSublists(self):        return [list(group) for group in mit.consecutive_groups(self.support)]        @property    def minIndex(self):        return np.min(np.where(self.v))            @property    def maxIndex(self):        return np.max(np.where(self.v))    @property    def ent(self):        return round(np.log2(np.sum(self.v)),4)    @property    def support(self):        return np.where(self.v)[0]        @property    def K(self):             return len(self.regex)        @property    def phi(self):        return self.ent + self.alpha * self.Kclass ALPHABET:   def __init__(self,alphabetList):      self.alphabetList = alphabetList           def sample(self,count=1):      return ''.join(random.choices(self.alphabetList,k=count))  class WORDCOLLECTION:    def __init__(self,words):        self.words = words        self.maxLength = max([len(word) for word in words])        self.M = [list(x) for x in self.words]        self.df = pd.DataFrame([list(word) for word in words])        self.prefixDicts = []        self.suffixDicts = []        self.spClasses = []        self.setToStr = lambda x : ''.join(sorted(list(x))) if isinstance(x,set) else x                self.dictValSetToStr = lambda d : dict([(k,self.setToStr(v)) for k,v in d.items()])                       for i in range(self.maxLength):            prefixes = {}            suffixes = {}                        if i != 0:                for v in self.M:                    if v[i] in prefixes.keys():                        prefixes[v[i]].add(v[i-1])                    else:                        prefixes[v[i]] = set(v[i-1])                 prefixes = self.dictValSetToStr(prefixes)                self.prefixDicts.append(prefixes)                            else:                pass                        if i != self.maxLength - 1:                                for v in self.M:                    if v[i] in suffixes.keys():                        suffixes[v[i]].add(v[i+1])                    else:                        suffixes[v[i]] = set(v[i+1])                suffixes = dict([(k,self.setToStr(v)) for k,v in suffixes.items()])                self.suffixDicts.append(suffixes)                            else:                pass    def createClasses(self):        eq = {}        #for k in set(list(preClasses.keys()) + list(suffClasses.keys())):        #    eq[k] = (preClasses.get(k,None),suffClasses.get(k,None))        for i in range(1,self.maxLength-1):            for k in set(list(self.prefixDicts[i].keys()) + list(self.suffixDicts[i].keys())):                eq[k] = (self.setToStr(self.prefixDicts[i].get(k,None)),self.setToStr(self.suffixDicts[i].get(k,None)))                            # The keys of eq are the alphabet. The values are each a tuple, where the first value is a             # string of the prefixes and the second is a string of the suffixes.            classes = self.partitionValueEquality(eq)            self.spClasses.append(classes)        self.spClasses = [self.partitionValueEquality(self.prefixDicts[0])] + self.spClasses        self.spClasses = self.spClasses + [self.partitionValueEquality(self.suffixDicts[-1])]                        def partitionValueEquality(self,inDict):        # returns a dictionary grouping the input dictionary keys by same value        outDict = {}        for k,v in inDict.items():            if v in outDict.keys():               outDict[v].add(k)            else:               outDict[v] = set(k)        outDict = self.dictValSetToStr(outDict)        return outDictclass GRAPH:   def __init__(self,regex=None,wordList=None,nodes=None,edges=None,alpha=1):      self.regex = regex      self.wordList = wordList      self.alpha = alpha       self.nodes = {}        self.edges = []      if self.regex:          try:              re.compile(self.regex)          except:             raise Exception('Invalid argument. re.compile failed')      elif self.wordList:         self.wordCollection = WORDCOLLECTION(self.wordList)         self.wordCollection.createClasses()            self.columnState = 0                  elif nodes:         self.nodes = nodes         self.edges = edges         else:        pass          if self.regex:         self.startNode = NODE(self.regex)         self.nodes.update({self.startNode.id_ : self.startNode})      else:        pass      self.simplify()              self.parallelPartition()            if not self.parallelGraphs and len(self.nodes)>1:         self.sequentialPartition()      else:         self.sequentialGraphs = None           def addNode(self,node):      if node.id_ in self.nodes.keys():            raise Exception('Node key already exists')      self.nodes[node.id_] = node   def addEdge(self,edge):      self.edges.append(edge)   def getEdge(self,parent,child):      matches = [edge for edge in self.edges if (edge.parent==parent and edge.child==child)]      if len(matches) > 1:         raise Exception ('More than one edge with same parent/child.')      elif len(matches) == 1:         return matches[0]      else:         return False           def removeEdge(self,parent,child):      toRemove = [edge for edge in self.edges if (edge.parent==parent and edge.child==child)]              if toRemove:        [self.edges.remove(edge) for edge in toRemove]   def getParents(self,id_):      return [x.parent for x in self.edges if x.child == id_]   def getChildren(self,id_):      return [x.child for x in self.edges if x.parent == id_]      def getNodesNoChildren(self):      return [x for x in self.nodes.values() if not self.getChildren(x.id_)]       def getNodesNoParents(self):      return [x.id_ for x in self.nodes.values() if not self.getParents(x.id_)]           def getNotSimple(self):       return [id_ for id_,node in self.nodes.items() if (not node.replaced and not node.simple)]   def simplify(self):      while self.getNotSimple():          self.process(self.getNotSimple()[0])        self.nodes = dict([(name,node) for name,node in self.nodes.items() if node.simple])   def getNodeEqClasses(self):       tempDict = {}       for id_ in self.nodes.keys():          parents = tuple(sorted(self.getParents(id_)))          children = tuple(sorted(self.getChildren(id_)))          if (parents,children) in tempDict.keys():              tempDict[(parents,children)].append(id_)          else:              tempDict[(parents,children)] = [id_]           return list(tempDict.values())   def getNodeAncestorsList(self,inList):       toReturn = []       for id_ in inList:          toReturn += self.getNodeAncestors(id_)       return toReturn       def getNodeDescendantsList(self,inList):       toReturn = []       for id_ in inList:            toReturn += self.getNodeDescendants(id_)       return toReturn       def getNodeAncestors(self,id_):       ancestors = []        parents = self.getParents(id_)       while parents:          parent = parents.pop()          parents += self.getParents(parent)          ancestors.append(parent)       return sorted(list(set(ancestors)))       def getNodeDescendants(self,id_):       descendants = self.getChildren(id_)       nextGen = descendants               while nextGen:          parents = nextGen          nextGen = []           for parent in parents:             nextGen += self.getChildren(parent)          descendants += nextGen       return descendants    def testCutSet(self,inList):        if not all([id_ in self.nodes.keys() for id_ in inList]):            raise Exception('Node included in inSet that is not in self.nodes.keys().')        else:            pass                allAncestors = []        allDescendants = []        for id_ in inList:            allAncestors += self.getNodeAncestors(id_)            allDescendants += self.getNodeDescendants(id_)        return set(inList + allAncestors + allDescendants) == set(self.nodes.keys())           def getCutSets(self):       eqClasses = self.getNodeEqClasses()       return [sorted(eqClass) for eqClass in eqClasses if self.testCutSet(eqClass)]                               def getNextCutSet(self,id_):       children = self.getChildren(id_)       while not (children in self.getCutSets()) and children:          newchildren = self.getChildren(children[0])          children = newchildren       return children       def getNodesBetweenCutSets(self,cutSetUpper,cutSetLower):       if cutSetUpper not in self.getCutSets()  and cutSetUpper != self.getNodesNoParents():          raise Exception('cutSetUpper is not a cutSet and is not noParents')                  if cutSetLower not in self.getCutSets():          raise Exception('cutSetLower is not a cutSet')                   if not all([node in self.getNodeDescendants(cutSetUpper[0]) for node in cutSetLower]):          raise Exception('cutSetUpper is not ancestor of cutSetLower')                     allDescendants = []       toExclude = cutSetLower.copy()       for node in cutSetLower:          toExclude += self.getNodeDescendants(node)               for node in cutSetUpper:          allDescendants += self.getNodeDescendants(node)       return sorted(list(set([x for x in allDescendants if x not in toExclude])))                           def addLayer(self):      if not self.wordCollection:         raise Exception('addLayer only used when wordCollection is provided')      else:         pass           newNodes = []        for n in self.wordCollection.spClasses[self.columnState].values():          newNodes.append(NODE(self.strToRegex(n)))                  if self.columnState == 0:         [self.addNode(node) for node in newNodes]            elif self.columnState == self.wordCollection.maxLength - 1:            print('All layers added')            return          else:           nodesNoChildren = self.getNodesNoChildren()         for word in self.wordCollection.words:             for node in nodesNoChildren:                match = node.match(word[0],boolean=True)                if match:                    parentNode = node                    break             for node in newNodes:                match = node.match(word[1],boolean=True)                if match:                    childNode = node                    existingEdge = self.getEdge(parentNode.id_,childNode.id_)                    if not existingEdge:                        edge = EDGE(parentNode.id_,childNode.id_,words = [word])                        self.addEdge(edge)                    else:                        existingEdge.words.append(word)                    break                                     [self.addNode(node) for node in newNodes]                        self.columnState += 1       def createVisual(self):      dot = Digraph()      #dot.node('',shape='point')           for key,node in self.nodes.items():         if not node.replaced:            if node.regex[0] == '\\':               display = '\\'+node.regex            else:               display = node.regex            dot.node(str(node.id_),display)            #for id_ in self.getNodesNoParents():      #   dot.edge('',id_)               for edge in self.edges:         dot.edge(edge.parent,edge.child)            dot.render(view=True)    def process(self,id_):                   if self.nodes[id_].topOrExists:         segments = getTopOrSegments(self.nodes[id_].regex)         self.nodes[id_].replaced = True         parents = self.getParents(self.nodes[id_].id_)         children = self.getChildren(self.nodes[id_].id_)         for segment in segments:                n = NODE(segment)                self.addNode(n)                for parent in parents:                   self.removeEdge(parent,self.nodes[id_].id_)                    self.addEdge(EDGE(parent,n.id_))                for child in children:                   self.removeEdge(self.nodes[id_].id_,child)                    self.addEdge(EDGE(n.id_,child))                                        elif '(' in self.nodes[id_].regex:         segments = getParenthesesSegments(self.nodes[id_].regex)         parents = self.getParents(self.nodes[id_].id_)         children = self.getChildren(self.nodes[id_].id_)         self.nodes[id_].replaced = True         n = NODE(segments[0])         self.addNode(n)         previous = n.id_         for parent in parents:             self.removeEdge(parent,self.nodes[id_].id_)             self.addEdge(EDGE(parent,n.id_))         for segment in segments[1:]:                #print('segment: ',segment)                n = NODE(segment)                self.addNode(n)                self.addEdge(EDGE(previous,n.id_))                previous = n.id_                           for child in children:                self.removeEdge(self.nodes[id_].id_,child)             self.addEdge(EDGE(n.id_,child))                   else:         cQList = getClassQuantList(self.nodes[id_].regex)         parents = self.getParents(self.nodes[id_].id_)         self.nodes[id_].replaced = True         toString = lambda d : d['class'] + d['quantifier'] if d['quantifier'] else d['class']         n = NODE(toString(cQList[0]),simple=True)         self.addNode(n)         previous = n.id_         for parent in parents:             self.addEdge(EDGE(parent,n.id_))                     self.removeEdge(parent,self.nodes[id_].id_)         for cQ in cQList[1:]:                n = NODE(toString(cQ),simple=True)                self.addNode(n)                self.addEdge(EDGE(previous,n.id_))                previous = n.id_                         children = self.getChildren(self.nodes[id_].id_)         for child in children:             self.removeEdge(self.nodes[id_].id_,child)              self.addEdge(EDGE(previous,child) )    def parallelPartition(self):      noParents = self.getNodesNoParents()            combs = list(combinations(noParents,2))      d = {}              for id_ in noParents:         d[id_] = self.getNodeDescendants(id_)                  pairs = []        for first,second in combs:           disjoint = set(d[first]).isdisjoint(d[second])         if not disjoint:            pairs.append([first,second])            sets = set([])      for id_ in noParents:                 matches = [pair for pair in pairs if id_ in pair]         if not matches:            sets.add(tuple([id_]))         else:                        sets.add(tuple(set([x for y in matches for x in y])))      parallel = []       for s in sets:                     nodes = set(s)         for node in s:            for descendant in self.getNodeDescendants(node):                nodes.add(descendant)         parallel.append(nodes)             for nodeSet in parallel:         if len(parallel) == 1:            self.parallelGraphs = None         else:             self.parallelGraphs = [self.createSubGraph(nodeSet) for nodeSet in parallel]                           def createSubGraph(self,nodeList):       subNodes = {}       subEdges = []       for node in nodeList:          subNodes[node] = self.nodes[node]       subEdges = [edge for edge in self.edges if (edge.parent in nodeList and edge.child in nodeList)]          subG = GRAPH(nodes=subNodes,edges=subEdges,alpha=self.alpha)       return subG                def sequentialPartition(self):       sequentialGraphsNodes = []       cutSets = self.getCutSets()       noParents = self.getNodesNoParents()           currentSet = noParents               nextCutSet = self.getNextCutSet(currentSet[0])       descendantList = self.getNodeDescendantsList(currentSet[0])       if not nextCutSet and descendantList:           if currentSet in cutSets:              sequentialGraphsNodes.append(currentSet)              sequentialGraphsNodes.append(descendantList)           else:              sequentialGraphsNodes.append(currentSet+descendantList)                   else:                       if currentSet in cutSets:               sequentialGraphsNodes.append(currentSet)                 firstSetAdded = True           else:              firstSet = currentSet              firstSetAdded = False              while nextCutSet or descendantList:               if nextCutSet:                  middle = self.getNodesBetweenCutSets(currentSet,nextCutSet)                  if not firstSetAdded:                     middle = firstSet + middle                     if middle:                     sequentialGraphsNodes.append(middle)                  sequentialGraphsNodes.append(nextCutSet)                   currentSet = nextCutSet.copy()                  descendantList = self.getNodeDescendantsList(nextCutSet)                  nextCutSet = self.getNextCutSet(nextCutSet[0])               else:                    if descendantList:                       sequentialGraphsNodes.append(descendantList)                    break       self.sequentialGraphs = []        for nodeSet in sequentialGraphsNodes:          self.sequentialGraphs.append(self.createSubGraph(nodeSet))       if len(self.sequentialGraphs) == 1:          self.sequentialGraphs = None       else:          pass       return   @property   def cardinality(self):      if self.parallelGraphs:         return sum([g.cardinality for g in self.parallelGraphs])      elif self.sequentialGraphs:         return np.prod([g.cardinality for g in self.sequentialGraphs])      else:         k = list(self.nodes.keys())[0]           return self.nodes[k].cardinality           @property   def K(self):       return len(self.outRegex)   @property   def outRegex(self):      if self.parallelGraphs:         toReturn = "(" + "|".join([g.outRegex for g in self.parallelGraphs]) + ")"      elif self.sequentialGraphs:         toReturn = "".join([g.outRegex for g in self.sequentialGraphs])      else:         k = list(self.nodes.keys())[0]           toReturn = self.nodes[k].regex      if toReturn[0] == '(' and toReturn[-1] == ')':         return toReturn[1:-1]      else:         return toReturn                   @property   def phi(self):       return round(np.log2(self.cardinality),4) + self.alpha * self.K